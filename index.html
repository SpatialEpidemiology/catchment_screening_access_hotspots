<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Healthcare Access & Screening Hotspots</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
  <style>
    /* (Existing CSS unchanged) */
    html, body, #map { height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI',… }
    /* ... other styles as before ... */
  </style>
</head>
<body>
  <!-- (Your existing UI structure remains unchanged) -->
  <div class="title-bar"><h1>Healthcare Access & Screening Hotspots</h1></div>
  <div id="map"></div>
  <div class="control-panel">…</div>
  <div class="legend"><h3>Legend</h3><div id="legend-content"></div></div>
  <div class="status-bar"><span id="status">Initializing map...</span></div>
  <div class="debug-panel" id="debugPanel"></div>
  <div class="solution-panel"><h3>GitHub Pages Solution</h3>
    <p>This implementation uses direct file access with correct CORS headers.</p>
    <p>No external proxies required!</p>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://unpkg.com/leaflet.vectorgrid@1.3.0/dist/Leaflet.VectorGrid.bundled.js"></script>
  <script src="https://unpkg.com/pmtiles@3.1.2/dist/umd/index.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const basePath = '/catchment_screening_access_hotspots/';
      const statusEl = document.getElementById('status');
      const debugPanel = document.getElementById('debugPanel');
      const debugToggle = document.getElementById('debugToggle');
      let debugLog = [];

      function debugLogMessage(message) {
        debugLog.push(new Date().toLocaleTimeString() + ': ' + message);
        if (debugLog.length > 10) debugLog.shift();
        if (debugPanel.style.display === 'block') {
          debugPanel.innerHTML = debugLog.join('<br>');
        }
      }

      debugToggle.addEventListener('change', function() {
        debugPanel.style.display = this.checked ? 'block' : 'none';
        if (this.checked) debugPanel.innerHTML = debugLog.join('<br>');
      });

      const map = L.map('map', { zoomControl: false }).setView([33.5186, -86.8104], 7);
      L.control.zoom({ position: 'topright' }).addTo(map);
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap &copy; CartoDB'
      }).addTo(map);

      let catchmentsLayer = null, catchmentsData = [];

      function loadCatchments() {
        statusEl.textContent = 'Loading catchments...';
        debugLogMessage('Fetching catchments from ' + basePath + 'assets/catchments.json');

        return fetch(basePath + 'assets/catchments.json')
          .then(r => { if (!r.ok) throw new Error('Failed loading: ' + r.status); return r.json(); })
          .then(geojson => {
            statusEl.textContent = 'Rendering catchments...';
            catchmentsData = geojson.features;
            catchmentsLayer = L.geoJSON(geojson, {
              style: { color: '#000', weight: 2, fillOpacity: 0, dashArray: '5,8', opacity: 0.7 }
            }).addTo(map);

            catchmentsLayer.on('click', function(e) {
              const latlng = e.latlng;
              const overlapping = catchmentsData.filter(f => {
                const bounds = L.geoJSON(f).getBounds();
                return bounds.contains(latlng) && isPointInPolygon(latlng, f);
              });

              if (overlapping.length) {
                const names = overlapping.map(f => f.properties?.name || 'Unnamed').join('<br>');
                L.popup()
                  .setLatLng(latlng)
                  .setContent(`<strong>Overlapping Catchments:</strong><br>${names}`)
                  .openOn(map);
              }
            });

            statusEl.textContent = 'Catchments loaded successfully';
            debugLogMessage('Rendered catchments successfully');
            return true;
          });
      }

      function isPointInPolygon(latlng, feature) {
        const pt = [latlng.lng, latlng.lat];
        const poly = feature.geometry.coordinates[0];
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i][0], yi = poly[i][1];
          const xj = poly[j][0], yj = poly[j][1];
          const intersect = ((yi > pt[1]) !== (yj > pt[1]))
            && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function initPMTiles() {
        if (typeof window.pmtiles === 'undefined') {
          statusEl.textContent = 'PMTiles lib not loaded. Showing catchments only.';
          debugLogMessage('PMTiles library missing');
          return;
        }

        try {
          const PMTiles = window.pmtiles.PMTiles;
          const protocol = new window.pmtiles.Protocol();

          const pm95 = new PMTiles(basePath + 'assets/sc_acc_hot_spots_overlap_95.pmtiles');
          const pm99 = new PMTiles(basePath + 'assets/sc_acc_hot_spots_overlap_99.pmtiles');

          window.pmtiles.registerProtocol(protocol);
          protocol.add(pm95); protocol.add(pm99);

          setupHotspotLayers(pm95, pm99);
          statusEl.textContent = 'PMTiles layers initialized';
          debugLogMessage('PMTiles initialized');
        } catch (err) {
          console.error(err);
          statusEl.textContent = 'PMTiles init error: ' + err.message;
          debugLogMessage('PMTiles init ERROR: ' + err.message);
        }
      }

      function setupHotspotLayers(pm95, pm99) {
        let currentLayer = null;

        function getColor(field, value) {
          if (typeof value === 'number') {
            if (field === 'COLON_SCRE') {
              if (value >= 80) return '#08306b';
              if (value >= 60) return '#2171b5';
              if (value >= 40) return '#4292c6';
              if (value >= 20) return '#6baed6';
              return '#9ecae1';
            }
            if (field === 'fin100k') {
              if (value >= 120) return '#4b0055';
              if (value >= 90) return '#7a3290';
              if (value >= 60) return '#985ea7';
              if (value >= 30) return '#b68bc1';
              return '#d5b6da';
            }
          }
          if (field === 'overlap_type') {
            if (value === 'Low Screening-Low Access Cluster') return '#d73027';
            if (value === 'High Screening-High Access Cluster') return '#1a9850';
            if (value === 'Non-significant') return '#999999';
          }
          return '#cccccc';
        }

        function createLayer(pmSource, fieldKey) {
          const base = fieldKey.replace(/_\d+$/, '');
          return L.vectorGrid.protobuf(pmSource.getURLTemplate(), {
            vectorTileLayerStyles: {
              '*': feature => {
                const v = feature.properties[fieldKey];
                return { fillColor: getColor(base, v), fillOpacity: 0.8,
                         color: '#444', weight: 0.3, opacity: 0.7 };
              }
            },
            maxZoom: 18, minZoom: 4, interactive: true,
            getFeatureId: f => f.properties.id || null
          }).on('click', e => {
            const p = e.layer.properties;
            let html = `<div class="popup-content"><strong>Tract ${p.id || ''}</strong><br>`;
            ['COLON_SCRE_95','COLON_SCRE_99','fin100k_95','fin100k_99','overlap_type_95','overlap_type_99']
              .forEach(key => { if (p[key] !== undefined) html += `${key}: ${p[key]}<br>`; });
            html += '</div>';
            L.popup().setLatLng(e.latlng).setContent(html).openOn(map);
          });
        }

        function updateLegend(fieldKey) {
          const base = fieldKey.replace(/_\d+$/, '');
          const legend = document.getElementById('legend-content');
          const conf = fieldKey.includes('_99') ? '99%' : '95%';
          let html = '';

          if (base === 'COLON_SCRE') {
            html += `<div class="legend-item"><span class="color-box" style="background:#08306b;"></span>≥ 80% (${conf})</div>
                     /*... other ranges ...*/`;
          } else if (base === 'fin100k') {
            html += `<div class="legend-item"><span class="color-box" style="background:#4b0055;"></span>≥ 120 (${conf})</div>
                     /*... other ranges ...*/`;
          } else if (base === 'overlap_type') {
            html += `<div class="legend-item"><span class="color-box" style="background:#d73027;"></span>Low‑Screening Low‑Access</div>
                     /*... other categories ...*/`;
          }

          legend.innerHTML = html;
        }

        function switchLayer(fieldKey) {
          if (currentLayer) map.removeLayer(currentLayer);
          debugLogMessage('Switching to ' + fieldKey);
          const src = fieldKey.includes('_95') ? pm95 : pm99;
          currentLayer = createLayer(src, fieldKey);
          currentLayer.addTo(map);
          updateLegend(fieldKey);
          statusEl.textContent = `Displaying ${fieldKey.replace('_', ' ')}`;
        }

        document.querySelectorAll('input[name="tractField"]').forEach(r => {
          r.addEventListener('change', e => { if (e.target.checked) switchLayer(e.target.value); });
        });

        switchLayer('COLON_SCRE_95');
        statusEl.textContent = 'Map ready with hotspot data';
      }

      loadCatchments().then(initPMTiles).catch(err => {
        console.error(err);
        statusEl.textContent = 'Load error: ' + err.message;
        debugLogMessage('ERROR loading catchments: ' + err.message);
      });
    });
  </script>
</body>
</html>
