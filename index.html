<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Healthcare Access & Screening Hotspots</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
  
  <style>
    html, body, #map { 
      height: 100%; 
      margin: 0; 
      padding: 0; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    #map { 
      width: 100%; 
      background: #f0f5f9;
    }

    .control-panel {
      position: absolute;
      top: 10px; 
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      border-radius: 8px;
      z-index: 1000;
      max-width: 260px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      border: 1px solid #ddd;
    }
    
    .control-panel h3 {
      margin-top: 0;
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 8px;
    }

    .legend {
      position: absolute;
      bottom: 20px; 
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      border-radius: 8px;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      border: 1px solid #ddd;
    }
    
    .legend h3 {
      margin-top: 0;
      color: #2c3e50;
      border-bottom: 1px solid #eee;
      padding-bottom: 8px;
    }

    .legend .color-box {
      display: inline-block;
      width: 20px; 
      height: 20px;
      margin-right: 8px;
      vertical-align: middle;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.2);
    }
    
    .legend-item {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    
    .radio-group {
      margin-bottom: 15px;
    }
    
    label {
      display: flex;
      align-items: center;
      margin: 5px 0;
      cursor: pointer;
      transition: all 0.2s;
      padding: 5px;
      border-radius: 4px;
    }
    
    label:hover {
      background: #f1f8ff;
    }
    
    input[type="radio"] {
      margin-right: 8px;
    }
    
    .title-bar {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 1000;
      pointer-events: none;
    }
    
    .title-bar h1 {
      display: inline-block;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 25px;
      border-radius: 30px;
      font-size: 1.4em;
      color: #2c3e50;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin: 0;
    }
    
    .status-bar {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 15px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    .error-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 8px;
      z-index: 2000;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      max-width: 400px;
    }
    
    .error-panel h2 {
      color: #d9534f;
      margin-top: 0;
    }
    
    .error-panel p {
      margin-bottom: 15px;
    }
    
    .btn {
      background: #5bc0de;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .btn:hover {
      background: #46b8da;
    }
    
    .catchment-popup-content {
      max-height: 200px;
      overflow-y: auto;
      min-width: 200px;
    }
    
    .catchment-item {
      padding: 8px 0;
      border-bottom: 1px solid #eee;
      font-size: 14px;
    }
    
    .catchment-item:last-child {
      border-bottom: none;
    }
    
    .catchment-name {
      font-weight: 600;
      color: #2c3e50;
    }
    
    .catchment-details {
      font-size: 12px;
      color: #666;
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <div class="title-bar">
    <h1>Healthcare Access & Screening Hotspots</h1>
  </div>
  
  <div id="map"></div>

  <div class="control-panel">
    <h3>95% Hotspot Tracts</h3>
    <div class="radio-group">
      <label><input type="radio" name="tractField" value="COLON_SCRE_95" checked> CRC screening (%)</label>
      <label><input type="radio" name="tractField" value="fin100k_95"> Primary care providers per 100k</label>
      <label><input type="radio" name="tractField" value="overlap_type_95"> Access-screening overlap</label>
    </div>

    <h3>99% Hotspot Tracts</h3>
    <div class="radio-group">
      <label><input type="radio" name="tractField" value="COLON_SCRE_99"> CRC screening (%)</label>
      <label><input type="radio" name="tractField" value="fin100k_99"> Primary care providers per 100k</label>
      <label><input type="radio" name="tractField" value="overlap_type_99"> Access-screening overlap</label>
    </div>
  </div>

  <div class="legend">
    <h3>Legend</h3>
    <div id="legend-content">
      <div class="legend-item">
        <div class="color-box" style="background: none; border: 2px dashed #000;"></div>
        <span>Healthcare Catchments</span>
      </div>
    </div>
  </div>
  
  <div class="status-bar">
    <span id="status">Initializing map...</span>
  </div>

  <!-- Load scripts at the end to ensure DOM is ready -->
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <!-- PMTiles support -->
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const statusEl = document.getElementById('status');
      
      // Initialize map with zoom controls
      const map = L.map('map', {
        preferCanvas: true // Use canvas renderer for better performance
      }).setView([33.5186, -86.8104], 7);
      
      // Add PMTiles protocol
      let protocol = new pmtiles.Protocol();
      maplibregl.addProtocol("pmtiles", protocol.tile);
      
      // Add base tile layer
      const baseLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; OpenStreetMap &copy; CartoDB',
        crossOrigin: 'anonymous' // Enable CORS for base tiles
      }).addTo(map);
      
      // Store catchments for overlap detection
      let catchmentsLayer = null;
      let catchmentsData = [];
      let pmtilesLayers = {};
      
      // PMTiles layer setup function
      function setupPMTilesLayer(url, layerName) {
        try {
          const p = new pmtiles.PMTiles(url);
          
          // Add the layer to Leaflet using a custom tile layer
          const pmtilesLayer = new L.GridLayer({
            attribution: 'PMTiles data',
            maxZoom: 18,
            tileSize: 512,
            zoomOffset: -1
          });
          
          pmtilesLayer.createTile = function(coords, done) {
            const tile = document.createElement('canvas');
            tile.width = 512;
            tile.height = 512;
            
            const ctx = tile.getContext('2d');
            
            // Fetch and render PMTiles data
            p.getZxy(coords.z, coords.x, coords.y).then(data => {
              if (data) {
                // Process the tile data (this would need to be adapted based on your PMTiles format)
                // For now, we'll create a placeholder
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(0, 0, 512, 512);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, 512, 512);
              }
              done(null, tile);
            }).catch(err => {
              console.error('PMTiles error:', err);
              done(err, null);
            });
            
            return tile;
          };
          
          pmtilesLayers[layerName] = pmtilesLayer;
          return pmtilesLayer;
        } catch (error) {
          console.error('Failed to setup PMTiles layer:', error);
          statusEl.textContent = `PMTiles error: ${error.message}`;
          return null;
        }
      }
      
      // Load catchments as GeoJSON with improved overlap detection
      function loadCatchments() {
        statusEl.textContent = 'Loading catchments...';
        
        return fetch('assets/catchments.json', {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          mode: 'cors' // Explicitly enable CORS
        })
          .then(response => {
            if (!response.ok) throw new Error(`Failed to load catchments: ${response.status} ${response.statusText}`);
            return response.json();
          })
          .then(geojson => {
            statusEl.textContent = 'Rendering catchments...';
            catchmentsData = geojson.features;
            
            // Add catchments to map with black dashed borders and no fill
            catchmentsLayer = L.geoJSON(geojson, {
              style: { 
                color: '#000000', // Black border
                weight: 2, 
                fillOpacity: 0,  // No fill
                dashArray: '5, 8', // Dashed line
                opacity: 0.7
              },
              onEachFeature: (feature, layer) => {
                // Store reference to the original feature
                layer.feature = feature;
                
                // Enhanced popup content
                if (feature.properties) {
                  const props = feature.properties;
                  let popupContent = `<div class="catchment-popup-content">`;
                  popupContent += `<div class="catchment-name">${props.name || 'Unnamed Catchment'}</div>`;
                  
                  // Add additional properties if available
                  if (props.type) {
                    popupContent += `<div class="catchment-details">Type: ${props.type}</div>`;
                  }
                  if (props.population) {
                    popupContent += `<div class="catchment-details">Population: ${props.population.toLocaleString()}</div>`;
                  }
                  if (props.area) {
                    popupContent += `<div class="catchment-details">Area: ${props.area} sq km</div>`;
                  }
                  
                  popupContent += `</div>`;
                  layer.bindPopup(popupContent);
                }
              }
            }).addTo(map);
            
            // Enhanced click handler for better overlap detection
            map.on('click', function(e) {
              const clickedLatLng = e.latlng;
              const overlappingCatchments = findOverlappingCatchments(clickedLatLng);
              
              if (overlappingCatchments.length > 1) {
                // Multiple catchments - show custom popup
                showCatchmentsPopup(clickedLatLng, overlappingCatchments);
              } else if (overlappingCatchments.length === 1) {
                // Single catchment - use default popup behavior
                const layer = findLayerForFeature(overlappingCatchments[0]);
                if (layer) {
                  layer.openPopup(clickedLatLng);
                }
              }
            });
            
            statusEl.textContent = `Catchments loaded successfully (${catchmentsData.length} features)`;
            return true;
          });
      }
      
      // Find the Leaflet layer corresponding to a GeoJSON feature
      function findLayerForFeature(feature) {
        let foundLayer = null;
        catchmentsLayer.eachLayer(layer => {
          if (layer.feature === feature) {
            foundLayer = layer;
          }
        });
        return foundLayer;
      }
      
      // Improved overlap detection using Leaflet's built-in methods
      function findOverlappingCatchments(latlng) {
        const overlapping = [];
        
        if (!catchmentsLayer) return overlapping;
        
        // Check each catchment layer
        catchmentsLayer.eachLayer(layer => {
          try {
            // First check if point is within layer bounds for efficiency
            if (layer.getBounds && layer.getBounds().contains(latlng)) {
              // Then do precise point-in-polygon check
              if (isPointInLayer(latlng, layer)) {
                overlapping.push(layer.feature);
              }
            }
          } catch (e) {
            console.error('Error checking point in polygon:', e);
          }
        });
        
        return overlapping;
      }
      
      // Improved point-in-polygon check using Leaflet's geometry
      function isPointInLayer(latlng, layer) {
        try {
          // For polygons, use a more robust point-in-polygon algorithm
          if (layer.getLatLngs) {
            const latlngs = layer.getLatLngs();
            
            // Handle different polygon structures
            let rings = [];
            if (latlngs.length > 0) {
              if (Array.isArray(latlngs[0])) {
                // MultiPolygon or Polygon with holes
                rings = latlngs;
              } else {
                // Simple polygon
                rings = [latlngs];
              }
            }
            
            // Check if point is in any of the polygon rings
            for (let ring of rings) {
              if (Array.isArray(ring[0])) {
                // This ring has sub-rings (polygon with holes)
                for (let subRing of ring) {
                  if (pointInPolygon(latlng, subRing)) {
                    return true;
                  }
                }
              } else {
                // Simple ring
                if (pointInPolygon(latlng, ring)) {
                  return true;
                }
              }
            }
          }
          return false;
        } catch (e) {
          console.error('Error in point-in-layer check:', e);
          return false;
        }
      }
      
      // Ray casting algorithm for point-in-polygon
      function pointInPolygon(point, polygon) {
        const x = point.lng;
        const y = point.lat;
        let inside = false;
        
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].lng;
          const yi = polygon[i].lat;
          const xj = polygon[j].lng;
          const yj = polygon[j].lat;
          
          if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
            inside = !inside;
          }
        }
        
        return inside;
      }
      
      // Enhanced popup for multiple overlapping catchments
      function showCatchmentsPopup(latlng, catchments) {
        let content = `<div class="catchment-popup-content">`;
        content += `<div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">`;
        content += `${catchments.length} Overlapping Catchments</div>`;
        
        catchments.forEach((catchment, index) => {
          const props = catchment.properties || {};
          const name = props.name || `Catchment ${index + 1}`;
          
          content += `<div class="catchment-item">`;
          content += `<div class="catchment-name">${name}</div>`;
          
          if (props.type) {
            content += `<div class="catchment-details">Type: ${props.type}</div>`;
          }
          if (props.population) {
            content += `<div class="catchment-details">Pop: ${props.population.toLocaleString()}</div>`;
          }
          content += `</div>`;
        });
        
        content += `</div>`;
        
        L.popup({
          maxWidth: 300,
          maxHeight: 200
        })
          .setLatLng(latlng)
          .setContent(content)
          .openOn(map);
      }
      
      // Load PMTiles files with CORS support
      function loadPMTilesFiles() {
        const pmtilesFiles = [
          // Add your PMTiles file URLs here
          // 'assets/your-file.pmtiles'
        ];
        
        pmtilesFiles.forEach((url, index) => {
          const layer = setupPMTilesLayer(url, `pmtiles-${index}`);
          if (layer) {
            // Optionally add to map
            // layer.addTo(map);
          }
        });
      }
      
      function showError(title, message) {
        // Remove any existing error panel
        const existingError = document.querySelector('.error-panel');
        if (existingError) {
          existingError.remove();
        }
        
        const errorPanel = document.createElement('div');
        errorPanel.className = 'error-panel';
        errorPanel.innerHTML = `
          <h2>${title}</h2>
          <p>${message}</p>
          <button class="btn" onclick="this.parentElement.remove()">Dismiss</button>
        `;
        
        document.body.appendChild(errorPanel);
      }
      
      // Radio button event handlers for tract fields
      document.querySelectorAll('input[name="tractField"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            statusEl.textContent = `Switched to: ${this.value}`;
            // Here you would update the visualization based on the selected field
            // This could involve loading different PMTiles or updating styling
          }
        });
      });
      
      // Start the initialization process
      Promise.all([
        loadCatchments(),
        loadPMTilesFiles()
      ]).then(() => {
        statusEl.textContent = 'Map loaded successfully';
      }).catch(error => {
        console.error('Error loading map data:', error);
        statusEl.textContent = `Load error: ${error.message}`;
        showError('Data Loading Error', 
          `Failed to load map data: ${error.message}. Please check that your data files are accessible and CORS is properly configured.`);
      });
    });
  </script>
</body>
</html>
